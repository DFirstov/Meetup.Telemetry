# Телеметрия в .NET: как затащить быстро и почти бесплатно

Телеметрия — это инструменты для наблюдения за приложением. В этом проекте даны примеры использования трёх инструментов телеметрии в распределённой системе на .NET: логирование, метрики и трассировка. Телеметрия добавляется в тестовый проект интернет-магазина (только backend). Для телеметрии используются только бесплатные инструменты с открытым исходным кодом. Тестовые микросервисы и все инструменты телеметрии поднимаются с помощью [docker-compose](https://docs.docker.com/compose/).

## Тестовая система

Тестовая система состоит из трёх микросервисов на ASP.NET Web API:

* [Payments](Payments/Program.cs) — пример сервиса для проведения оплаты. На каждый запрос генерирует случайные данные о пользователе и его балансе. Затем проверяет, достаточно ли у пользователя средств для совершения покупки. Если денег хватает, возвращает успешный ответ. Если нет, возвращает ошибку 400.
* [Stock](Stock/Program.cs) — пример сервиса для работы со складом. Может возвращать список продуктов, доступных на складе, и позволяет бронировать определённый продукт. При бронировании продукта случайным образом определяет, доступен ли он на складе. Если доступен, то возвращает успешный ответ. Если нет, возвращает ошибку 400.
* [Shop](Shop/Program.cs) — пример сервиса витрины интернет-магазина. Позволяет получить список товаров со склада и принимает запросы на покупку продукта. Перед покупкой проверяет, доступен ли продукт на складе. Если доступен, то проводит оплату. Если оплата прошла успешно, то возвращает успешный ответ. Если продукт недоступен или оплата не прошла, возвращает ошибку 400.

Кроме этого, есть тестовый клиент [LoadTest](LoadTest/Program.cs), который бесконечно отправляет запросы на покупку продукта в магазин.

Запустить тестовую систему можно с помощью docker-compose:

```bash
docker-compose up
```

Системы начнут обмениваться запросами (честное слово!), но мы об этом не узнаем, т. к. у нас нет никакой телеметрии. Остановить систему можно с помощью `Ctrl+C`.

## Логирование

Логи — это краткие текстовые записи, описывающие происходящее в системе. Помимо текста логи содержат следующую информацию:

* Уровень логирования, который показывает важность сообщения. Например, уровень `Error` — это сообщение об ошибке, которое нужно обязательно проверить. Уровень `Information` — это обычное сообщение, которое нужно проверить, если что-то не работает.
* Дата и время сообщения, которые позволяют сопоставить события по времени их происхождения.
* Дополнительная структурированная информация, которая может быть полезна при поиске ошибок. Например, в логах могут быть записаны имя пользователя, который совершил действие, или идентификатор запроса. Обычно эта информация записывается в формате JSON и обрабатывается системой хранения логов.

### Добавление логов

Добавим логирование в нашу систему. Для этого в каждый из проектов потребуется добавить следующие NuGet-пакеты (сейчас можно не выполнять — они уже добавлены в проекты):

```bash
dotnet add package Serilog.AspNetCore
dotnet add package Serilog.Extensions.Logging
dotnet add package Serilog.Sinks.Seq
```

Теперь сконфигурируем логирование в каждом из проектов. Для этого в каждом проекте в `Program.cs` добавим следующий код:

```csharp
builder.Host.UseSerilog((_, loggerConfiguration) => loggerConfiguration
    .MinimumLevel.Debug()         // Минимальный уровень логирования. Логи с меньшим уровнем не будут записаны
	.WriteTo.Console()            // Пишем логи в консоль
	.WriteTo.Seq("http://seq"));  // Отправляем логи в систему хранения логов Seq
```

После этого в обработчиках запросов мы можем писать логи. Для этого нужно добавить в каждый обработчик параметр `ILogger` с атрибутом `FromServices`. Далее, внутри обработчика можно вызывать методы этого объекта, соответствующие уровню логирования:

```csharp
app.MapGet("/products", ([FromServices] ILogger logger) =>
{
	logger.Debug("Getting products"); // Логируем сообщение с уровнем Debug
	return products;
});
```

Для записи структурной информации используются фигурные скобки:

```csharp
logger.Warning("Product {Product} not found", product); // Добавляем логу свойство Product
```

Чтобы записать сложный объект, в фигурные скобки добавляется @ (без этого объект будет приводиться к строке методом `ToString()`):

```csharp
record ClientAccount(
	string ClientName,
	decimal Balance);

var clientAccount = GetClientAccount(sum);
logger.Debug("Paying {Sum} roubles from the account {@ClientAccount}", sum, clientAccount);
```

### Просмотр логов

Запустим систему:

```bash
docker-compose up
```

Теперь мы увидим в консоли информацию об обработке запросов:

```log
[04:24:41 DBG] Paying 2496 roubles from the account {"ClientName": "Yoko", "Balance": 23419, "$type": "ClientAccount"}
```

Система для хранения логов Seq тоже поднята в docker-compose. Она доступна по адресу [http://localhost:5341](http://localhost:5341). Напишем в строке поиска запрос на поиск платежей по имени клиента:

```
ClientAccount.ClientName = 'Yoko'
```

Seq выдаст нам все логи о платежах этого клиента. Также поддерживаются более сложные запросы:

```
ClientAccount.ClientName = 'Yoko' and ClientAccount.Balance < 10000
```

Подробнее о языке запросов можно прочитать в [документации](https://docs.datalust.co/docs/the-seq-query-language).

### Маскирование логов

Для изучения маскирования логов переключитесь на ветку `1-2-mask-logs`:

```bash
git checkout 1-2-mask-logs
```
